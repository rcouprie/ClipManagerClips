<?xml version="1.0" encoding="UTF-8"?><FMClipboard><Version><![CDATA[42052142]]></Version><Comment><![CDATA[UniqueID aangepast aan Table
m_PrimeryKey, documentatie en ~primery05]]></Comment><SourceWindowName><![CDATA[Clip Manager]]></SourceWindowName><Class>XMFN</Class><ClipVersion>1.02</ClipVersion><ClipTimeStamp>-2.147484e+9</ClipTimeStamp><ClipAuthor><![CDATA[richard]]></ClipAuthor><clipboardAsText><![CDATA[!filemakerstandards.org( pageID )#( name;value )#Assign( parameters )#AssignGlobal( parameters )#Filter( parameters;filterParameters )#Get( parameters;name )#Remove( parameters;removeParameters )Debug(  )Developer(  )Dirname( path )Error(  )ErrorData(  )ErrorString( type;num )FieldName( fieldRef )FieldReps( veld )LoopCounter( iterator )m_PrimeryKey(  )Null(  )ObjectFieldID( field;file )ObjectFieldName( id;table;file )ObjectLayoutID( name;file )ObjectLayoutName( id;file )ObjectLayoutNumber( id;file )ObjectScriptID( name;file )ObjectScriptName( id;file )ObjectTableID( table;file )ObjectTableName( id;file )ObjectValueListID( name;file )ObjectValueListName( id;file )RepList( veld )RepListLoop( veld;repMax;rep )ScriptOptionalParameterList( scriptNameToParse )ScriptRequiredParameterList( scriptNameToParse )SetError( type;num;dialog;capture;halt )Tab(  )TableName( fieldRef )securityToegang( extendedPrivilegeNaam )TriggersAreActive(  )TriggersDisable(  )TriggersEnable(  )TriggersReset(  )UniqueID(  )VariableList( keys;values;scope )VerifyVariablesNotEmpty( nameList )WindowCenter( dimension )WindowProperties(  )]]></clipboardAsText><Clipboard><fmxmlsnippet type="FMObjectList"><CustomFunction id="6" functionArity="1" visible="True" parameters="pageID" name="!filemakerstandards.org"><Calculation>"http://filemakerstandards.org/pages/viewpage.action?pageId=" &amp; pageID</Calculation></CustomFunction><CustomFunction id="7" functionArity="2" visible="True" parameters="name;value" name="#"><Calculation>/**
 * =====================================
 * # ( name ; value )
 *
 * RETURNS:
 *		An name-value pair in Let notation.
 *
 * PARAMETERS:
 *		name: The name for the returned name-value pair. name can be any value
 *		that would be a valid Let() variable name.
 *		value: The value for the returned name-value pair.
 *
 * EXAMPLE:
 *		# ( "name"; $value ) &amp; # ( "foo" ; "bar" )
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		MODIFIED on 2013-01-14 by Daniel Smith dansmith65@gmail.com to include
 *		trailing return on error result and accept a value of "?"
 *		MODIFIED on 2012-12-12 by Daniel Smith dansmith65@gmail.com to preserve
 *		data type of value
 *		MODIFIED on 2012-12-07 by Jeremy Bante &lt;http://scr.im/jbante&gt; where an
 *		error result could create invalid sytax for values containing a comment
 *		close sequence.
 *		MODIFIED on 2012-11-28 by Jeremy Bante &lt;http://scr.im/jbante&gt; to return
 *		error feedback, and to prefix names with "$".
 *		CREATED on 2012-11-10 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 * =====================================
 */

Let ( [
	// characters used as separators in a date field
	~DATECHARS = "\/-" ;
	// characters used as separators in a time field
	~TIMECHARS = ":" ;
	
	~name =	// strip leading "$$" and "$"
		Substitute (
			"/*start*/" &amp; name;
			[ "/*start*/$$" ; "" ];
			[ "/*start*/$" ; "" ];
			[ "/*start*/" ; "" ]
		);
	~value =
		Case (
			// test for specific values that will be treated as a number in the next section
			value = "" or value = "?" ;
			Quote ( value ) ;
			
			value ≠ GetAsNumber ( value ) ;
			Quote ( value ) ;
			
			// value is a number, timestamp, date, or time
			Case (
				// negative time value
				value &lt; 0 and not IsEmpty ( Filter ( value ; ~TIMECHARS ) ) ;
				"GetAsTime ( " &amp; Quote( value ) &amp; " )" ;
				
				not IsEmpty ( Filter ( value ; ~DATECHARS ) )
					and not IsEmpty ( Filter ( value ; ~TIMECHARS ) )
				;
				"GetAsTimestamp ( " &amp; Quote( value ) &amp; " )" ;
				
				not IsEmpty ( Filter ( value ; ~TIMECHARS ) ) ;
				"GetAsTime ( " &amp; Quote( value ) &amp; " )" ;
				
				/**
				 * At this point, if value is less than 1, it must be either
				 * a negative number or a decimal exponent.
				 * This section must be after test for time because time can
				 * contain a negative number.
				 * This section should be before test for date, because a date
				 *   can contain a -, which is also used for a negative number.
				 */
				value &lt; 1 ;
				"GetAsNumber ( " &amp; GetAsNumber( value ) &amp; " )" ;
				
				not IsEmpty ( Filter ( value ; ~DATECHARS ) ) ;
				"GetAsDate ( " &amp; Quote( value ) &amp; " )" ;

				/**
				 * either a number, or:
				 * if the ~DATECHARS and ~TIMECHARS variables do not contain the
				 * separator chars in use on the current computer, store the
				 * date/time/timestamp as a number
				 */
				"GetAsNumber ( " &amp; GetAsNumber( value ) &amp; " )"
			)
		) ;
	~result =
		"$"
		&amp; ~name
		&amp; " = "
		&amp; ~value
		&amp; ";¶";
	~testExpression =
		"Let ( [ "
		&amp; ~result
		&amp; " ~ = \"\" ]; \"\" )";
	~error =
		Case (
			IsEmpty ( ~name );
				11;	// Name is not valid

			not IsValidExpression ( ~testExpression );
				1200	// Generic calculation error
		)
];
	If ( ~error;	// prevent bad pairs from affecting evaluation by commenting
		"/* Error "
		&amp; ~error
		&amp; " name: "
		&amp; Quote (
			Substitute (	// escape comment character sequences
				name ;
				[ "*/" ; "\*\/" ];
				[ "/*" ; "\/\*" ]
			)
		)
		&amp; " value: "
		&amp; Quote (
			Substitute (	// escape comment character sequences
				value ;
				[ "*/" ; "\*\/" ];
				[ "/*" ; "\/\*" ]
			)
		)
		&amp; " */"
		&amp; ¶;
	/* Else */
		~result
	)
)</Calculation></CustomFunction><CustomFunction id="8" functionArity="1" visible="True" parameters="parameters" name="#Assign"><Calculation>/**
 * =====================================
 * #Assign ( parameters )
 *
 * PURPOSE:
 *		Parses a Let dictionary of name-value parameters into a series of
 *		locally scoped $variables.
 *
 * RETURNS:
 *		FileMaker's error code from any errors encountered during evaluation.
 *
 * PARAMETERS:
 *		parameters: A Let format dictionary, such as produced by the
 *		# ( name ; value ) function.
 *
 * DEPENDENCIES: none
 *
 * NOTES:
 *		Notes go here
 *
 * HISTORY:
 *		MODIFIED on 2012-11-28 by Jeremy Bante &lt;http://scr.im/jbante&gt; to support
 *		"$" prefix values as default.
 *		CREATED on 2012-11-11 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 * =====================================
 */

Let ( [
	~error =
		EvaluationError ( Evaluate (
			"Let ( [¶"
			&amp; Substitute (	// convert global variables to local variables
				¶ &amp; parameters;
				"¶$$";
				"¶$"
			)
			&amp; "¶~ = \"\" ]; ~ )"
		) )
];
	~error = 0	// indicate success or failure of Evaluate()
	or Let ( $#Assign.error = ~error ; False )	// only runs on error
)</Calculation></CustomFunction><CustomFunction id="9" functionArity="1" visible="True" parameters="parameters" name="#AssignGlobal"><Calculation>/**
 * =====================================
 * #AssignGlobal ( parameters )
 *
 * PURPOSE:
 *		Parses a Let dictionary of name-value parameters into a series of
 *		globally scoped $$VARIABLES.
 *
 * RETURNS:
 *		FileMaker's error code from any errors encountered during evaluation.
 *
 * PARAMETERS:
 *		parameters: A Let format dictionary, such as produced by the
 *		# ( name ; value ) function.
 *
 * DEPENDENCIES: none
 *
 * NOTES:
 *		Notes go here
 *
 * HISTORY:
 *		CREATED on 2012-12-04 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 * =====================================
 */

Let ( [
	~error =
		EvaluationError ( Evaluate (
			"Let ( ["
			&amp; Substitute (	// convert $local to $$GLOBAL variables
				¶ &amp; parameters;
				[ "¶$$" ; "¶$" ];	// ... without renaming existing $$GLOBALS
				[ "¶$" ; "¶$$" ]
			)
			&amp; "¶~ = \"\" ]; ~ )"
		) )
];
	~error = 0	// indicate success or failure of Evaluate()
	or Let ( $#AssignGlobal.error = ~error ; False )	// only runs on error
)</Calculation></CustomFunction><CustomFunction id="10" functionArity="2" visible="True" parameters="parameters;filterParameters" name="#Filter"><Calculation>/**
 * =====================================
 * #Filter ( parameters ; filterParameters )
 *
 * RETURNS:
 *		A list of Let notation name-value pairs from parameters with names in
 *		filterParameters. Any pairs with names not in filterParameters will not
 *		be included.
 *
 * PARAMETERS:
 *		parameters: A string of serialized name-value pair data in Let notation.
 *		filterParameters: A return-delimited list of parameter names to include
 *		in the result.
 *
 * EXAMPLE:
 *		#Assign ( #Filter (
 *			# ( "name" ; "value" )
 *			&amp; # ( "foo" ; "bar" );
 *			List ( "name" ; "otherName" )
 *		) )
 *		// variable $name assigned "value"; $foo and $otherName are unaffected
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		CREATED on 2012-11-28 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 * =====================================
 */

Case (
	/* Step 0, set-up */
	not $#Filter.step ;
		Let ( [
			~empty = IsEmpty ( parameters ) or IsEmpty ( filterParameters ) ;
			filterParameters =	// add "$" prefix for matching
				Substitute ( ¶ &amp; filterParameters ; ¶ ; "¶$" ) ;
			filterParameters =	// add "$$" prefix for backwards-compatibility
				filterParameters
				&amp; Substitute ( filterParameters ; ¶ ; "¶$" )
				&amp; ¶ ;

			$#Filter.parameterCount = ValueCount ( parameters ) ;
			$#Filter.step = If ( ~empty ; -1 ; /* Else */ 1 )
		];
			#Filter ( parameters ; filterParameters )
		);

	/* Step 1, do stuff */
	$#Filter.step = 1 ;
		Let ( [
			$#Filter.i = $#Filter.i + 1 ;
			~pair = GetValue ( parameters ; $#Filter.i ) ;
			~name = Left ( ~pair ; Position ( ~pair ; " = " ; 1 ; 1 ) - 1 ) ;
			$#Filter.result =
				// only include ~pair if ~name is in filterParameters
				List (
					$#Filter.result ;
					If ( Position ( filterParameters ; ¶ &amp; ~name &amp; ¶ ; 1 ; 1 ) &gt; 0;
						~pair
					)
				);

			$#Filter.step =
				If ( $#Filter.i &lt; $#Filter.parameterCount ;
					$#Filter.step ;
					/* Else */ $#Filter.step + 1
				)
		];
			#Filter ( parameters ; filterParameters )
		);

	/* Step 2, clean-up and return result */
	$#Filter.step = 2 or $#Filter.step = -1 ;
		Let ( [
			~error = $#Filter.step = -1 ;
			~result = $#Filter.result ;

			// purge variables
			$#Filter.i = "" ;
			$#Filter.parameterCount = "" ;
			$#Filter.result = "" ;
			$#Filter.step = ""
		];
			If ( ~error ; "" ; /* Else */ ~result )
		)
)</Calculation></CustomFunction><CustomFunction id="11" functionArity="2" visible="True" parameters="parameters;name" name="#Get"><Calculation>/**
 * =====================================
 * #Get ( parameters ; name )
 *
 * RETURNS:
 *		A named value from a string of name-value pairs.
 *
 * PARAMETERS:
 *		parameters: A string of name-value pairs
 *		name: The name to retrieve the value of
 *
 * DEPENDENCIES: none
 *
 * NOTES:
 *		When a name is defined more than once in parameters, the last value is
 *		returned.
 *
 * HISTORY:
 *		MODIFIED on 2013-01-08 by Jeremy Bante &lt;http://scr.im/jbante&gt; to handle
 *		leading $$ and $ in the name parameter the same as the
 *		# ( name ; value ) function, based on a comment by Dan Smith.
 *		CREATED on 2012-12-05 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 * =====================================
 */

Let ( [
	parameters = ¶ &amp; parameters &amp; ¶;
	name =	// strip any leading $$ or $ for backwards compatibility
		Substitute ( ¶ &amp; name ; [ "¶$$" ; "" ] ; [ "¶$" ; "" ] ; [ ¶ ; "" ] ) ;

	~length = Length ( parameters );
	~namePosition =	// position of last occurrence of name
		Position ( parameters ; "¶$" &amp; name &amp; " = " ; ~length ; -1 );
	~namePosition =	// check for $$global name for backwards compatibility
		If ( ~namePosition &gt; 0;
			~namePosition;
		/* Else */
			Position ( parameters ; "¶$$" &amp; name &amp; " = " ; ~length ; -1 )
		);

	~valueStart = Position ( parameters ; " = " ; ~namePosition ; 1 ) + 3;
	~valueEnd = Position ( parameters ; ";¶" ; ~namePosition ; 1 );
	~value = Middle ( parameters ; ~valueStart ; ~valueEnd - ~valueStart )
];
	// check that ~value exists and is valid
	If ( ~namePosition &gt; 0 and IsValidExpression ( ~value );
		Evaluate ( ~value )
	)
)</Calculation></CustomFunction><CustomFunction id="12" functionArity="2" visible="True" parameters="parameters;removeParameters" name="#Remove"><Calculation>Case (
	/* Step 0, set-up */
	not $#Remove.step ;
		Let ( [
			~empty = IsEmpty ( parameters ) or IsEmpty ( removeParameters ) ;
			removeParameters =	// add "$" prefix for matching
				Substitute ( ¶ &amp; removeParameters ; ¶ ; "¶$" ) ;
			removeParameters =	// add "$$" prefix for backwards-compatibility
				removeParameters
				&amp; Substitute ( removeParameters ; ¶ ; "¶$" )
				&amp; ¶ ;

			$#Remove.parameterCount = ValueCount ( parameters ) ;
			$#Remove.step = If ( ~empty ; -1 ; /* Else */ 1 )
		];
			#Remove ( parameters ; removeParameters )
		);

	/* Step 1, check each parameter */
	$#Remove.step = 1 ;
		Let ( [
			$#Remove.i = $#Remove.i + 1 ;
			~pair = GetValue ( parameters ; $#Remove.i ) ;
			~name = Left ( ~pair ; Position ( ~pair ; " = " ; 1 ; 1 ) - 1 ) ;
			$#Remove.result =
				// only include ~pair if ~name is not in removeParameters
				List (
					$#Remove.result ;
					If ( Position ( removeParameters ; ¶ &amp; ~name &amp; ¶ ; 1 ; 1 ) = 0;
						~pair
					)
				);

			$#Remove.step =
				If ( $#Remove.i &lt; $#Remove.parameterCount ;
					$#Remove.step ;
					/* Else */ $#Remove.step + 1
				)
		];
			#Remove ( parameters ; removeParameters )
		);

	/* Step 2, clean-up and return result */
	$#Remove.step = 2 or $#Remove.step = -1 ;
		Let ( [
			~error = $#Remove.step = -1 ;
			~result = $#Remove.result ;

			// purge variables
			$#Remove.i = "" ;
			$#Remove.parameterCount = "" ;
			$#Remove.result = "" ;
			$#Remove.step = ""
		];
			If ( ~error ; parameters ; /* Else */ ~result )
		)
)</Calculation></CustomFunction><CustomFunction id="13" functionArity="0" visible="True" parameters="" name="Debug"><Calculation>/**
 * =====================================================
 * Debug ( )
 * 
 * PARAMETERS:
 *		none
 *
 * RETURNS:
 *		string) A list of informative values
 * 		about the current FMP environment.
 *
 * DEPENDENCIES:
 * 		Developer ()
 *
 * NOTES:
 *
 * RELEASE:
 * 		101009 - Initial by Matt Petrowsky
 * 		2013-01-25 - Updated to be recursive and use better output. Included more functions
 * =====================================================
 * 
 */

If ( Developer;
	Let ( [
		~input = List (
			"Environment";
			"	ApplicationVersion";
			"	SystemPlatform";
			"	SystemVersion";
			"	ApplicationLanguage";
			"	SystemLanguage";
			"	HostName";
			"	HostApplicationVersion";
			"	SystemIPAddress";
			"	HostIPAddress";
			"	CurrentTimeStamp";
			"	CurrentHostTimeStamp";
			"	InstalledFMPlugins";
			"	AllowAbortState";
			"	ConnectionState";
			"	CustomMenuSetName";
			"	FileName";
			"	FileSize";
			"	FoundCount";
			"	SystemNICAddress";
			"	PersistentID";
			"	RecordOpenCount";
			"Errors";
			"	LastError";
			"	LastODBCError";
			"User";
			"	AccountName";
			"	AccountPrivilegeSetName";
			"	CurrentPrivilegeSetName";
			"	AccountExtendedPrivileges";
			"	CurrentExtendedPrivileges";
			"Layout";
			"	LayoutName";
			"	LayoutNumber";
			"	LayoutTableName";
			"	LayoutViewState";
			"	LayoutAccess";
			"	LayoutTableName";
			"	ActiveLayoutObjectName";
			"	ActivePortalRowNumber";
			"Records";
			"	RecordID";
			"	RecordNumber";
			"	RecordAccess";
			"	RecordModificationCount";
			"	RecordOpenState";
			"	SortState";
			"	TotalRecordCount";
			"Field";
			"	ActiveFieldName";
			"	ActiveFieldTableName";
			"	ActiveFieldContents";
			"	ActiveRepetitionNumber";
			"	ActiveSelectionStart";
			"	ActiveSelectionSize";
			"	CalculationRepetitionNumber";
			"Script";
			"	ScriptName";
			"	ScriptParameter";
			"	ScriptResult";
			"Paths";
			"	TemporaryPath";
			"	DesktopPath";
			"	DocumentsPath";
			"	FileMakerPath";
			"	FilePath";
			"	PreferencesPath";
			"	SystemDrive";
		);
		~tab = "	";
		~line = GetValue ( ~input ; $~debugCounter );
		~eval = If ( Left ( ~line ; 1 ) = ~tab ; // evaluate lines prefixed with tabs
			Let ( [
				~function = Trim ( ~line );
				~padding = "                              "; // 30 chars is longest function name
				~result = Evaluate ( "Get(" &amp; ~function &amp; ")" )
			];
				~function
				&amp; Left ( ~padding ; Length ( ~padding ) - Length ( ~function ) ) // spacing out result
				&amp; If ( ValueCount ( ~result ) &gt; 1; // some functions return multiple lines
					Substitute ( ~result ; ¶ ; ¶ &amp; ~tab &amp; Left ( ~padding ; Length ( ~padding ) - 1 ) );
					~result
				)
			);

			~line
		);
		~lastValue = RightWords ( ~input ; 1 );
		~itemCount = ValueCount ( ~input );
		$~debugOutput = List ( $~debugOutput ; ~eval )
	];
		If ( $~debugCounter = ~itemCount;
			// don't want the result to continously build and length will vary based on function results with multiple lines
			Left ( $~debugOutput ; Position ( $~debugOutput ; ¶ ; Position ( $~debugOutput ; ~lastValue ; 1 ; 1 ) ; 1 ) - 1 ); // better way to do this?
			Let ( $~debugCounter = $~debugCounter + 1 ; Debug ) )
	)
)</Calculation></CustomFunction><CustomFunction id="14" functionArity="0" visible="True" parameters="" name="Developer"><Calculation>/**
 * =====================================================
 * Developer ( )
 *		https://github.com/petrowsky/fmpstandards/blob/master/Functions/Developer.fmfn
 * 
 * PARAMETERS:
 *		none
 *
 * RETURNS:
 *		(bool) True or False based on proper   
 *		evaluation
 *
 * DEPENDENCIES:
 *		none
 *
 * NOTES:
 *		Because Filemaker Changed Get ( PrivilegeSetName )
 *		Evaluate () must be used
 *
 * RELEASE:
 *		2011-02-23
 * =====================================================
 * 
 */

Let ( [ 

	~developers = List ( "" ; "" );  // Add names of the accounts which are valid developer accounts
	~version = Get ( ApplicationVersion );
	~isGo = PatternCount ( ~version; "Go" ) = True;
	~versionNumber = GetAsNumber ( Substitute ( ~version ; "," ; "." ) ); // account for foreign versions using comma
	~extendedPrivileges = // Add "developer" extended privilege to groups which are valid developer groups
		If (  ~isGo or ~versionNumber ≥ 11;
			Evaluate ( "Get ( AccountExtendedPrivileges )" );
			/*else*/ Evaluate ( "Get ( ExtendedPrivileges )" )
		)

];

	PatternCount ( ¶&amp; ~developers &amp;¶ ; ¶&amp; Get ( AccountName ) &amp;¶ ) ≥ 1
	or PatternCount ( ¶&amp; ~extendedPrivileges &amp;¶ ; ¶&amp; "developer" &amp;¶ ) ≥ 1
	or
	If ( ~isGo or ~versionNumber ≥ 11;
		Evaluate ( "Get ( AccountPrivilegeSetName )" ) = "[Full Access]";
		/*else*/ Evaluate ( "Get ( PrivilegeSetName )" ) = "[Full Access]"
	)

)</Calculation></CustomFunction><CustomFunction id="15" functionArity="1" visible="True" parameters="path" name="Dirname"><Calculation>/**
 * =====================================================
 * Dirname ( path )
 * 
 * PURPOSE:
 *		Return the parent folder of the
 *		supplied path
 * PARAMETERS:
 *		path
 * RETURNS:
 *		(string) path to parent folder
 * DEPENDENCIES:
 *		none
 * NOTES:
 * =====================================================
 * 
 */

Let ( [
	~separatorMac = PatternCount ( path ; "/" );
	~separatorWin = PatternCount ( path ; "\\" );
	~separator = If ( ~separatorMac &gt; 0 ; "/" ; "\\");
	~lastCharIsSeparator = Right ( path ; 1 ) = ~separator;
	~pathParts = Substitute ( path ; ~separator ; ¶ );
	~partCount = ValueCount ( ~pathParts )
];

	Substitute ( LeftValues ( ~pathParts ; If ( ~lastCharIsSeparator ; ~partCount ; ~partCount -1 ) - 1 ) ; ¶ ; ~separator )

)

/*
//Unit tests
List (
	Dirname ( "/Volumes/Macintosh HD/Users/User Name/Library/Application Support/FileMaker/Extensions/" );
	Dirname ( "C:\Documents and Settings\User Name\Local Settings\Application Data\FileMaker\Extensions\" );
	Dirname ( "C:\Users\User Name\AppData\Local\FileMaker\Extensions" );
	Dirname ( "file:Folder/Parent/Path" );
)
*/</Calculation></CustomFunction><CustomFunction id="16" functionArity="0" visible="True" parameters="" name="Error"><Calculation>/**
 * =====================================
 * Error ( )
 *
 * PURPOSE:
 *		Assign reserved $error* variables to contain a package of
 *		useful error handing information. Default assignment assumes
 *		a FileMaker error and can be overridden to contain errors
 *		related to plugins, the solution or other custom functions.
 *		
 * RETURNS:
 *		A Let() formatted array of error $variables and error related data
 *		
 * PARAMETERS:
 *		none
 *
 * EXAMPLES:
 * 		Error // to return information about an internal FileMaker error
 *		# ( "$error" ; Error ) // passing the packed $error variable into a script
 *		# ( "$error" ; Error  &amp; # ( "$errorHalt" ; False ) &amp; # ( "$errorDialog" ; False ) &amp; # ( "$errorCapture" ; False ) ) // inline overrides
 *
 * DEPENDENCIES:
 *		ErrorString(), ErrorData()
 *
 * NOTES:
 *		Error handling can be accomplished in a variety of ways when scripting.
 *		This function returns a pre-defined set of reserved variables for use
 *		when handling errors. The variables declared below should ONLY be used
 *		within your solution for the purpose of error handling.
 *		IMPORTANT!! When capturing errors, you should handle the error within
 *		the script where the error might occur. This allows you to know which
 *		script caused the error.
 *
 * HISTORY:
 *		MODIFIED on 2011-03-20 by matt@filemakermagazine.com - reformatted
 *
 * REFERENCES:
 *		none
 * =====================================
 */

Let (
	~error = Get ( LastError );
	
	Substitute ( // add semi-colons for proper Let() formatting
		List (
			"$errorState = " &amp; If ( ~error ≠ 0 ; True ; False );
			"$errorType = " &amp; Quote ( "fmp" ); // enumeration fmp, app, plugin, func
			"$errorNum = " &amp; ~error; // set to your own error or plugin error when overriding
			"$errorString = " &amp; Quote ( ErrorString ( If ( IsEmpty ( $errorType ) ; "fmp" ; $errorType ) ; ~error ) ); // set your own string if needed
			"$errorScript = " &amp; Quote ( Get ( ScriptName ) );
			// only set defaults if not already set
			"$errorHalt = " &amp; If ( not IsEmpty ( $errorHalt ) ; $errorHalt ; True );
			"$errorDialog = " &amp; If ( not IsEmpty ( $errorDialog ) ; $errorDialog ; True );
			"$errorCapture = " &amp; If ( not IsEmpty ( $errorCapture ) ; $errorCapture ; True );
		);
		[ ¶ ; ";¶" ]
	)
	&amp; ";" &amp; ErrorData &amp; ";¶"
)

/*
Unit tests
Using #Assign to make sure the Error variables will be set.

#Assign ( Error );
*/

/*
# Example script with various types of calls using Error()

# Standard FileMaker error with presets
Set Variable [ $errorHalt; Value:False ]
Set Variable [ $errorDialog; Value:False ]
Set Variable [ $errorCapture; Value:False ]
Perform Script [ “Handle Error ( error )”; Parameter: # ( "$error" ; Error ) ]
#----------------------------------
# Standard FileMaker error with inline overrides (simplified from above)
Perform Script [ “Handle Error ( error )”; Parameter: # ( "$error" ; Error &amp; # ( "$errorHalt" ; False ) &amp; # ( "$errorDialog" ; False ) &amp; # ( "$errorCapture" ; False ) ) ]
#----------------------------------
# Custom Application error
# (see SetError fuction)
Perform Script [ “Handle Error ( error )”; Parameter: # ( "$error" ; SetError ( "app" ; 200 ; True ; True ; False ) ) ]
#
Exit Script [ Result: List ( # ( "$result" ; True ) ; # ( "$error" ; Error ) ) ]

*/</Calculation></CustomFunction><CustomFunction id="17" functionArity="0" visible="True" parameters="" name="ErrorData"><Calculation>/**
 * =====================================
 * ErrorData ( )
 *
 * PURPOSE:
 *		Provide extended error related information when calling the Error() function
 *		
 * RETURNS:
 *		A Let() formatted array of error related variables used by Error()
 *		
 * PARAMETERS:
 *		none
 *
 * EXAMPLES:
 * 		(see Error function)
 *
 * DEPENDENCIES:
 *		none
 *
 * NOTES:
 *		ErrorData is expected to be modified based on the solution being
 *		designed. Additional information may be added to the result of
 *		ErrorData for the purpose of capturing the error data into an error
 *		log table. Anything contained within this funtion is provided within
 *		the reserved variable of $errorData and can be evaluated with the
 *		#Assign() function. You can append your own fixed error data or
 *		include any other error related functions.
 *
 * HISTORY:
 *		MODIFIED on 2011-03-20 by matt@filemakermagazine.com - reformatted
 *
 * REFERENCES:
 *		none
 * =====================================
 */

Substitute (
	List (
		"$errorFile = " &amp; Quote ( Get ( FileName ) );
		"$errorType = " &amp; Quote ( If ( IsEmpty ( $errorType ) ; "fmp" ; $errorType ) );
		"$scriptParameter = " &amp; Quote ( Get ( ScriptParameter ) );
		"$scriptResult = " &amp; Quote ( Get ( ScriptResult ) );
		"$lastODBCError = " &amp; Quote ( Get ( LastODBCError ) );
		"$layoutName = " &amp; Quote ( Get ( LayoutName ) );
		"$layoutTableName = " &amp; Quote ( Get ( LayoutTableName ) );
		"$recordOpenCount = " &amp; Get ( RecordOpenCount );
		"$recordModificationCount = " &amp; Get ( RecordModificationCount );
		"$activeFieldName = " &amp; Quote ( Get ( ActiveFieldName ) );
		"$activeFieldTableName = " &amp; Quote ( Get ( ActiveFieldTableName ) );
		"$activeLayoutObjectName = " &amp; Quote ( Get ( ActiveLayoutObjectName ) );
		// Add any additional application specific error data here
	);
	[ ¶ ; ";¶" ]
)

/*
Unit tests
Using #Assign to make sure the Error variables will be set.

#Assign ( ErrorData );
*/</Calculation></CustomFunction><CustomFunction id="18" functionArity="2" visible="True" parameters="type;num" name="ErrorString"><Calculation>/**
 * =====================================
 * ErrorString ( type ; num )
 *
 * PURPOSE:
 *		Provide the human-readable error string associated to a numerical error
 *		
 * RETURNS:
 *		(string) An error respective of the type of error
 *		
 * PARAMETERS:
 *		type = (enumeration) fmp, app, plugin, func
 *		num = (number) the numerical value for that error type
 *
 * EXAMPLES:
 *		(see Error function)
 *
 * DEPENDENCIES:
 *		none
 *
 * NOTES:
 *		The ErrorString function can be used to contain your own
 *		solution specific errors. It is advised that you use
 *		numerical values within reserved ranges.
 *
 * HISTORY:
 *		MODIFIED on 2012-07-02 by matt@filemakermagazine.com - fmp 12v1
 *		MODIFIED on 2011-03-20 by matt@filemakermagazine.com - reformatted
 *
 * REFERENCES:
 *		http://www.filemaker.com/help/html/error_codes.html
 * =====================================
 */

Case (
	type = "fmp";
		Case (
			num = -1; "Unknown error";
			num = 0; "No error";
			num = 1; "User canceled action";
			num = 2; "Memory error";
			num = 3; "Command is unavailable (for example, wrong operating system, wrong mode, etc.)";
			num = 4; "Command is unknown";
			num = 5; "Command is invalid (for example, a Set Field script step does not have a calculation specified)";
			num = 6; "File is read-only";
			num = 7; "Running out of memory";
			num = 8; "Empty result";
			num = 9; "Insufficient privileges";
			num = 10; "Requested data is missing";
			num = 11; "Name is not valid";
			num = 12; "Name already exists";
			num = 13; "File or object is in use";
			num = 14; "Out of range";
			num = 15; "Can't divide by zero";
			num = 16; "Operation failed, request retry (for example, a user query)";
			num = 17; "Attempt to convert foreign character set to UTF-16 failed";
			num = 18; "Client must provide account information to proceed";
			num = 19; "String contains characters other than A-Z, a-z, 0-9 (ASCII)";
			num = 20; "Command/operation canceled by triggered script";
			num = 100; "File is missing";
			num = 101; "Record is missing";
			num = 102; "Field is missing";
			num = 103; "Relationship is missing";
			num = 104; "Script is missing";
			num = 105; "Layout is missing";
			num = 106; "Table is missing";
			num = 107; "Index is missing";
			num = 108; "Value list is missing";
			num = 109; "Privilege set is missing";
			num = 110; "Related tables are missing";
			num = 111; "Field repetition is invalid";
			num = 112; "Window is missing";
			num = 113; "Function is missing";
			num = 114; "File reference is missing";
			num = 115; "Menu set is missing";
			num = 116; "Layout object is missing";
			num = 117; "Data source is missing";
			num = 118; "Theme is missing";
			num = 130; "Files are damaged or missing and must be reinstalled";
			num = 131; "Language pack files are missing (such as template files)";
			num = 200; "Record access is denied";
			num = 201; "Field cannot be modified";
			num = 202; "Field access is denied";
			num = 203; "No records in file to print, or password doesn't allow print access";
			num = 204; "No access to field(s) in sort order";
			num = 205; "User does not have access privileges to create new records; import will overwrite existing data";
			num = 206; "User does not have password change privileges, or file is not modifiable";
			num = 207; "User does not have sufficient privileges to change database schema, or file is not modifiable";
			num = 208; "Password does not contain enough characters";
			num = 209; "New password must be different from existing one";
			num = 210; "User account is inactive";
			num = 211; "Password has expired";
			num = 212; "Invalid user account and/or password; please try again";
			num = 213; "User account and/or password does not exist";
			num = 214; "Too many login attempts";
			num = 215; "Administrator privileges cannot be duplicated";
			num = 216; "Guest account cannot be duplicated";
			num = 217; "User does not have sufficient privileges to modify administrator account";
			num = 218; "Password and verify password do not match";
			num = 300; "File is locked or in use";
			num = 301; "Record is in use by another user";
			num = 302; "Table is in use by another user";
			num = 303; "Database schema is in use by another user";
			num = 304; "Layout is in use by another user";
			num = 306; "Record modification ID does not match";
			num = 307; "Transaction could not be locked because of a communication error with the host";
			num = 308; "Theme is in use by another user";
			num = 400; "Find criteria are empty";
			num = 401; "No records match the request";
			num = 402; "Selected field is not a match field for a lookup";
			num = 403; "Exceeding maximum record limit for trial version of FileMaker Pro";
			num = 404; "Sort order is invalid";
			num = 405; "Number of records specified exceeds number of records that can be omitted";
			num = 406; "Replace/Reserialize criteria are invalid";
			num = 407; "One or both match fields are missing (invalid relationship)";
			num = 408; "Specified field has inappropriate data type for this operation";
			num = 409; "Import order is invalid";
			num = 410; "Export order is invalid";
			num = 412; "Wrong version of FileMaker Pro used to recover file";
			num = 413; "Specified field has inappropriate field type";
			num = 414; "Layout cannot display the result";
			num = 415; "One or more required related records are not available";
			num = 416; "Primary key required from data source table";
			num = 417; "Database is not a supported data source";
			num = 500; "Date value does not meet validation entry options";
			num = 501; "Time value does not meet validation entry options";
			num = 502; "Number value does not meet validation entry options";
			num = 503; "Value in field is not within the range specified in validation entry options";
			num = 504; "Value in field is not unique as required in validation entry options";
			num = 505; "Value in field is not an existing value in the database file as required in validation entry options";
			num = 506; "Value in field is not listed on the value list specified in validation entry option";
			num = 507; "Value in field failed calculation test of validation entry option";
			num = 508; "Invalid value entered in Find mode";
			num = 509; "Field requires a valid value";
			num = 510; "Related value is empty or unavailable";
			num = 511; "Value in field exceeds maximum field size";
			num = 512; "Record was already modified by another user";
			num = 600; "Print error has occurred";
			num = 601; "Combined header and footer exceed one page";
			num = 602; "Body doesn't fit on a page for current column setup";
			num = 603; "Print connection lost";
			num = 700; "File is of the wrong file type for import";
			num = 706; "EPSF file has no preview image";
			num = 707; "Graphic translator cannot be found";
			num = 708; "Can't import the file or need color monitor support to import file";
			num = 709; "QuickTime movie import failed";
			num = 710; "Unable to update QuickTime reference because the database file is read-only";
			num = 711; "Import translator cannot be found";
			num = 714; "Password privileges do not allow the operation";
			num = 715; "Specified Excel worksheet or named range is missing";
			num = 716; "A SQL query using DELETE, INSERT, or UPDATE is not allowed for ODBC import";
			num = 717; "There is not enough XML/XSL information to proceed with the import or export";
			num = 718; "Error in parsing XML file (from Xerces)";
			num = 719; "Error in transforming XML using XSL (from Xalan)";
			num = 720; "Error when exporting; intended format does not support repeating fields";
			num = 721; "Unknown error occurred in the parser or the transformer";
			num = 722; "Cannot import data into a file that has no fields";
			num = 723; "You do not have permission to add records to or modify records in the target table";
			num = 724; "You do not have permission to add records to the target table";
			num = 725; "You do not have permission to modify records in the target table";
			num = 726; "There are more records in the import file than in the target table; not all records were imported";
			num = 727; "There are more records in the target table than in the import file; not all records were updated";
			num = 729; "Errors occurred during import; records could not be imported";
			num = 730; "Unsupported Excel version (convert file to Excel 2000 format or a later supported version and try again)";
			num = 731; "File you are importing from contains no data";
			num = 732; "This file cannot be inserted because it contains other files";
			num = 733; "A table cannot be imported into itself";
			num = 734; "This file type cannot be displayed as a picture";
			num = 735; "This file type cannot be displayed as a picture; it will be inserted and displayed as a file";
			num = 736; "Too much data to export to this format; it will be truncated";
			num = 737; "Bento table you are importing is missing";
			num = 800; "Unable to create file on disk";
			num = 801; "Unable to create temporary file on System disk";
			num = 802; "Unable to open file.¶This error can be caused by one or more of the following:¶ • Invalid database name¶ • File is closed in FileMaker Server¶ • Invalid permission";
			num = 803; "File is single user or host cannot be found";
			num = 804; "File cannot be opened as read-only in its current state";
			num = 805; "File is damaged; use Recover command";
			num = 806; "File cannot be opened with this version of FileMaker Pro";
			num = 807; "File is not a FileMaker Pro file or is severely damaged";
			num = 808; "Cannot open file because access privileges are damaged";
			num = 809; "Disk/volume is full";
			num = 810; "Disk/volume is locked";
			num = 811; "Temporary file cannot be opened as FileMaker Pro file";
			num = 813; "Record Synchronization error on network";
			num = 814; "File(s) cannot be opened because maximum number is open";
			num = 815; "Couldn't open lookup file";
			num = 816; "Unable to convert file";
			num = 817; "Unable to open file because it does not belong to this solution";
			num = 819; "Cannot save a local copy of a remote file";
			num = 820; "File is in the process of being closed";
			num = 821; "Host forced a disconnect";
			num = 822; "FMI files not found; reinstall missing files";
			num = 823; "Cannot set file to single-user, guests are connected";
			num = 824; "File is damaged or not a FileMaker file";
			num = 825; "File is not authorized to reference the protected file";
			num = 826; "File path specified is not a valid file path";
			num = 850; "Path is not valid for the operating system";
			num = 851; "Cannot delete an external file from disk";
			num = 852; "Cannot write a file to the external storage";
			num = 900; "General spelling engine error";
			num = 901; "Main spelling dictionary not installed";
			num = 902; "Could not launch the Help system";
			num = 903; "Command cannot be used in a shared file";
			num = 905; "No active field selected; command can only be used if there is an active field";
			num = 906; "Current file is not shared; command can be used only if the file is shared";
			num = 920; "Can’t initialize the spelling engine";
			num = 921; "User dictionary cannot be loaded for editing";
			num = 922; "User dictionary cannot be found";
			num = 923; "User dictionary is read-only";
			num = 951; "An unexpected error occurred (*)";
			num = 954; "Unsupported XML grammar (*)";
			num = 955; "No database name (*)";
			num = 956; "Maximum number of database sessions exceeded (*)";
			num = 957; "Conflicting commands (*)";
			num = 958; "Parameter missing (*)";
			num = 959; "Custom Web Publishing technology disabled";
			num = 960; "Parameter is invalid";
			num = 1200; "Generic calculation error";
			num = 1201; "Too few parameters in the function";
			num = 1202; "Too many parameters in the function";
			num = 1203; "Unexpected end of calculation";
			num = 1204; "Number, text constant, field name or \"(\" expected";
			num = 1205; "Comment is not terminated with \"*/\"";
			num = 1206; "Text constant must end with a quotation mark";
			num = 1207; "Unbalanced parenthesis";
			num = 1208; "Operator missing, function not found or \"(\" not expected";
			num = 1209; "Name (such as field name or layout name) is missing";
			num = 1210; "Plug-in function has already been registered";
			num = 1211; "List usage is not allowed in this function";
			num = 1212; "An operator (for example, +, -, *) is expected here";
			num = 1213; "This variable has already been defined in the Let function";
			num = 1214; "AVERAGE, COUNT, EXTEND, GETREPETITION, MAX, MIN, NPV, STDEV, SUM and GETSUMMARY: expression found where a field alone is needed";
			num = 1215; "This parameter is an invalid Get function parameter";
			num = 1216; "Only Summary fields allowed as first argument in GETSUMMARY";
			num = 1217; "Break field is invalid";
			num = 1218; "Cannot evaluate the number";
			num = 1219; "A field cannot be used in its own formula";
			num = 1220; "Field type must be normal or calculated";
			num = 1221; "Data type must be number, date, time, or timestamp";
			num = 1222; "Calculation cannot be stored";
			num = 1223; "Function referred to is not yet implemented";
			num = 1224; "Function referred to does not exist";
			num = 1225; "Function referred to is not supported in this context";
			num = 1300; "The specified name can’t be used";
			num = 1400; "ODBC client driver initialization failed; make sure the ODBC client drivers are properly installed";
			num = 1401; "Failed to allocate environment (ODBC)";
			num = 1402; "Failed to free environment (ODBC)";
			num = 1403; "Failed to disconnect (ODBC)";
			num = 1404; "Failed to allocate connection (ODBC)";
			num = 1405; "Failed to free connection (ODBC)";
			num = 1406; "Failed check for SQL API (ODBC)";
			num = 1407; "Failed to allocate statement (ODBC)";
			num = 1408; "Extended error (ODBC)";
			num = 1409; "Error (ODBC)";
			num = 1413; "Failed communication link (ODBC)";
			num = 1414; "SQL statement is too long";
			num = 1450; "Action requires PHP privilege extension (*)";
			num = 1451; "Action requires that current file be remote";
			num = 1501; "SMTP authentication failed";
			num = 1502; "Connection refused by SMTP server";
			num = 1503; "Error with SSL";
			num = 1504; "SMTP server requires the connection to be encrypted";
			num = 1505; "Specified authentication is not supported by SMTP server";
			num = 1506; "Email(s) could not be sent successfully";
			num = 1507; "Unable to log in to the SMTP server";
			num = 1550; "Cannot load the plug-in or the plug-in is not a valid plug-in";
			num = 1551; "Cannot install the plug-in. Cannot delete an existing plug-in or cannot write to the folder or disk";
			num = 1626; "Protocol is not supported";
			num = 1627; "Authentication failed";
			num = 1628; "There was an error with SSL";
			num = 1629; "Connection timed out; the timeout value is 60 seconds";
			num = 1630; "URL format is incorrect";
			num = 1631; "Connection failed";
			"Unknown error"
		);

	type = "app"; // you can use your own ~ErrorApplication (private function) for app errors
		Case (
			num = 100; "My custom app error";
			num = 200; "Another custom app error";
			"Unknown error"
		);

	type = "plugin"; // you can use your own ~ErrorPlugins (private function) for plugin errors
		"Add plugin specific handling here";

	"Unknown error"
)</Calculation></CustomFunction><CustomFunction id="19" functionArity="1" visible="True" parameters="fieldRef" name="FieldName"><Calculation>/**
 * =====================================
 * FieldName ( fieldRef )
 *
 * PURPOSE:
 *		Convenience function for working with
 *		abstracted field references within code.
 *		
 * RETURNS:
 *		(string) name of just the field portion from a field reference
 *		
 * PARAMETERS:
 *		fieldRef = Absolute field reference
 *
 * EXAMPLES:
 *		TableName ( FunctionalArea » Tablename::fieldName ) = "FunctionalArea » Tablename"
 *
 * DEPENDENCIES:
 *		none
 *
 * NOTES:
 *		This is simply a helper function to avoid having excessive amounts of
 *		similar code wtihin a FileMaker solution.
 *
 * HISTORY:
 *		MODIFIED on 2012-05-11 by matt@filemakermagazine.com - added
 *
 * REFERENCES:
 *		(see TableName custom function)
 * =====================================
 */

GetValue ( Substitute ( GetFieldName ( fieldRef ) ; "::" ; ¶ ) ; 2 )</Calculation></CustomFunction><CustomFunction id="20" functionArity="1" visible="True" parameters="veld" name="FieldReps"><Calculation>// geeft het aantal repetitions van een veld.

GetAsNumber ( FieldType ( Get ( FileName ) ; GetFieldName ( veld ) ) )</Calculation></CustomFunction><CustomFunction id="21" functionArity="1" visible="True" parameters="iterator" name="LoopCounter"><Calculation>/**
 * =====================================================
 * LoopCounter ( iterator )
 *
 * PURPOSE:
 *		Provide a human-readable loop iterator within
 *		scripted Loop[] steps.
 *
 * PARAMETERS:
 *		iterator = (string) name of the iterator variable
 *
 * EXAMPLES:
 * 		Loop
 *			Exit Loop If [LoopCounter ( "i" ) &gt; $itemCount]
 *			# Do loop steps here
 *		End Loop
 *
 * RETURNS:
 * 		(variable) Incremented variable
 *
 * DEPENDENCIES:
 *		none 
 *
 * NOTES:
 *		A local variable is created, don't use the same name for
 *		a script variable.
 *		Adapted from http://www.fmfunctions.com/fid/278
 *
 * HISTORY:
 *		9/28/11 - Matt Petrowsky
 * =====================================================
 * 
 */

Let ( ~variable = "$" 
		&amp; Substitute ( iterator ; "$" ; "" )
	;
	Evaluate ( "Let ( " &amp; ~variable &amp; " = " &amp; ~variable &amp; " +1 ; " &amp; ~variable &amp; " )" )
)</Calculation></CustomFunction><CustomFunction id="55" functionArity="0" visible="True" parameters="" name="m_PrimeryKey"><Calculation>/**
 * =====================================
 * m_PrimeryKey ( )
 *
 * PURPOSE:
 *		Find the Primery Key in a table
 *
 * RETURNS:
 *		Error (0) if no match; Value of Primery Key ( Field ) otherwise.
 *
 * PARAMETERS:
 *		n.a. = not available
 *
 * DEPENDENCIES:
 *		none
 *
 * EXAMPLE:
 *		set $id = m_PrimeryKey
 *
 * VERSION:
 *		0.3	12-12-2013: Updated with primery05
 *		0.2	06-06-2013: Updated with primery04
 * RELEASE: 
 *		0.1	01-02-2013 Updated with primery05
 *
 * REFERENCES:
 *		
 * =====================================
 */

Let ( [
	  ~primery01 = "___kp_ID"
	; ~primery02 = "__kp_ID"
	; ~primery03 = "id prime"
	; ~primery04 = "id"
	; ~primery05 = "___pk_ID"

	; ~table = Get ( LayoutTableName)
] ;
	Case ( 
	  EvaluationError (  GetField ( ~table &amp; "::" &amp; ~primery01 ) ) = 0
		; GetField (  ~table &amp; "::" &amp; ~primery01 )

	; EvaluationError (  GetField (  ~table &amp; "::" &amp; ~primery02   )) = 0
		; GetField (  ~table &amp;  "::" &amp; ~primery02  )

	; EvaluationError (  GetField (  ~table &amp; "::" &amp; ~primery03   ) ) = 0
		; GetField (  ~table &amp; "::" &amp; ~primery03 )

	; EvaluationError (  GetField (  ~table &amp; "::" &amp; ~primery04   ) ) = 0
		; GetField (  ~table &amp; "::" &amp; ~primery04 )

	; #( "error" ; "geen Primery key op layout: " &amp; Get ( LayoutName ) &amp; "@" &amp; Get ( LayoutTableName ) )
	)

)</Calculation></CustomFunction><CustomFunction id="22" functionArity="0" visible="True" parameters="" name="Null"><Calculation>// This function is intentionally blank. Please do not return a result</Calculation></CustomFunction><CustomFunction id="23" functionArity="2" visible="True" parameters="field;file" name="ObjectFieldID"><Calculation>/**
 * =====================================
 * ObjectFieldID ( field ; file )
 *
 * RETURNS:
 *		FileMaker's internal ID for a field.
 *
 * PARAMETERS:
 *		field: The field (not literal field name) to retrieve the ID of.
 *		file: The name of the FileMaker file containing the field.
 *
 * DEPENDENCIES: none
 *
 * NOTE:
 *		If there is a layout in the file with the same name as the field's
 *		table, the field must be on that layout for this function to work.
 *
 * HISTORY:
 *		MODIFIED on 2012-01-26 by Jeremy Bante to accept the file parameter.
 *		CREATED on 2011-06-01 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~fieldName = Substitute ( GetFieldName ( field ) ; "::" ; "¶" );
	~tableName = GetValue ( ~fieldName ; 1 );
	~fieldName = GetValue ( ~fieldName ; 2 );

	~nameList = ¶ &amp; FieldNames ( file ; ~tableName ) &amp; ¶;
	~value =
		Position ( ~nameList ; ¶ &amp; ~fieldName &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~nameList ; ~value ) ; "¶" )
];
	GetValue ( FieldIDs ( file ; ~tableName ) ; ~value )
)</Calculation></CustomFunction><CustomFunction id="24" functionArity="3" visible="True" parameters="id;table;file" name="ObjectFieldName"><Calculation>/**
 * =====================================
 * ObjectFieldName ( id ; table ; file )
 *
 * RETURNS:
 *		The current name of a FileMaker field, based on its ID.
 *
 * PARAMETERS:
 *		file: The name of the FileMaker file containing the field.
 *		theFieldID: FileMaker's internal ID for the field.
 *
 * DEPENDENCIES: none
 *
 * NOTE:
 *		If there is a layout in the file with the same name as the field's
 *		table, the field must be on that layout for this function to work.
 *
 * HISTORY:
 *		CREATED on 2012-01-26 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~idList = ¶ &amp; FieldIDs ( file ; table ) &amp; ¶;
	~value =
		Position ( ~idList ; ¶ &amp; id &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~idList ; ~value ) ; "¶" )
];
	GetValue ( FieldNames ( file ; table ) ; ~value )
)</Calculation></CustomFunction><CustomFunction id="25" functionArity="2" visible="True" parameters="name;file" name="ObjectLayoutID"><Calculation>/**
 * =====================================
 * ObjectLayoutID ( name ; file )
 *
 * RETURNS:
 *		FileMaker's internal ID for a layout.
 *
 * PARAMETERS:
 *		name: The name of the layout
 *		file: The name of the FileMaker file containing the layout.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		MODIFIED on 2012-01-26 by Jeremy Bante to accept the file parameter.
 *		CREATED on 2011-06-01 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~nameList = ¶ &amp; LayoutNames ( file ) &amp; ¶;
	~value =
		Position ( ~nameList ; ¶ &amp; name &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~nameList ; ~value ) ; ¶ )
];
	GetValue ( LayoutIDs ( file ) ; ~value )
)</Calculation></CustomFunction><CustomFunction id="26" functionArity="2" visible="True" parameters="id;file" name="ObjectLayoutName"><Calculation>/**
 * =====================================
 * ObjectLayoutName ( id ; file )
 *
 * RETURNS:
 *		The current name of a FileMaker layout, based on its ID.
 *
 * PARAMETERS:
 *		id: FileMaker's internal ID for the layout.
 *		file: The name of the FileMaker file containing the layout.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		CREATED on 2012-01-26 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~idList = ¶ &amp; LayoutIDs ( file ) &amp; ¶;
	~value =
		Position ( ~idList ; ¶ &amp; id &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~idList ; ~value ) ; ¶ )
];
	GetValue ( LayoutNames ( file ) ; ~value )
)</Calculation></CustomFunction><CustomFunction id="27" functionArity="2" visible="True" parameters="id;file" name="ObjectLayoutNumber"><Calculation>/**
 * =====================================
 * ObjectLayoutNumber ( file ; id )
 *
 * RETURNS:
 *		The current number of a FileMaker layout, based on its ID.
 *
 * PARAMETERS:
 *		id: FileMaker's internal ID for the layout.
 *		file: The name of the FileMaker file containing the layout.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		CREATED on 2012-09-05 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~idList = ¶ &amp; LayoutIDs ( file ) &amp; ¶;
	~value =
		Position ( ~idList ; ¶ &amp; id &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~idList ; ~value ) ; ¶ )
];
	~value
)</Calculation></CustomFunction><CustomFunction id="28" functionArity="2" visible="True" parameters="name;file" name="ObjectScriptID"><Calculation>/**
 * =====================================
 * ObjectScriptID ( name ; file )
 *
 * RETURNS:
 *		FileMaker's internal ID for a script.
 *
 * PARAMETERS:
 *		name: The name of the script
 *		file: The name of the FileMaker file containing the script.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		MODIFIED on 2012-02-20 by Jeremy Bante &lt;http://scr.im/jbante&gt; to return
 *		an error value (-1) for unknown scripts.
 *		CREATED on 2012-01-26 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~nameList = ¶ &amp; ScriptNames ( file ) &amp; ¶;
	~value =
		Position ( ~nameList ; ¶ &amp; name &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~nameList ; ~value ) ; ¶ );
	~id = GetValue ( ScriptIDs ( file ) ; ~value )
];
	If ( IsEmpty ( ~id ) ; -1 ; /* Else */ ~id )
)</Calculation></CustomFunction><CustomFunction id="29" functionArity="2" visible="True" parameters="id;file" name="ObjectScriptName"><Calculation>/**
 * =====================================
 * ScriptIDName ( id ; file )
 *
 * RETURNS:
 *		The current name of a FileMaker script, based on its ID.
 *
 * PARAMETERS:
 *		id: FileMaker's internal ID for the script.
 *		file: The name of the FileMaker file containing the script.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		MODIFIED on 2012-02-20 by Jeremy Bante &lt;http://scr.im/jbante&gt; to return
 *		descriptive text for bad IDs.
 *		CREATED on 2012-01-26 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~idList = ¶ &amp; ScriptIDs ( file ) &amp; ¶;
	~value =
		Position ( ~idList ; ¶ &amp; id &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~idList ; ~value ) ; ¶ );
	~name = GetValue ( ScriptNames ( file ) ; ~value )
];
	If ( IsEmpty ( ~name ) ; "?" ; /* Else */ ~name )
)</Calculation></CustomFunction><CustomFunction id="30" functionArity="2" visible="True" parameters="table;file" name="ObjectTableID"><Calculation>/**
 * =====================================
 * ObjectTableID ( table ; file )
 *
 * RETURNS:
 *		FileMaker's internal ID for a table.
 *
 * PARAMETERS:
 *		table: Table Occurrence name
 *		file: The name of the FileMaker file containing the table.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		MODIFIED on 2012-01-26 by Jeremy Bante to accept the file parameter.
 *		CREATED on 2011-06-01 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~nameList = ¶ &amp; TableNames ( file ) &amp; ¶;
	~value =
		Position ( ~nameList ; ¶ &amp; table &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~nameList ; ~value ) ; ¶ )
];
	GetValue ( TableIDs ( file ) ; ~value )
)</Calculation></CustomFunction><CustomFunction id="31" functionArity="2" visible="True" parameters="id;file" name="ObjectTableName"><Calculation>/**
 * =====================================
 * ObjectTableName ( id ; file )
 *
 * RETURNS:
 *		The current name of a FileMaker script, based on its ID.
 *
 * PARAMETERS:
 *		id: FileMaker's internal ID for the table.
 *		file: The name of the FileMaker file containing the table.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		CREATED on 2012-01-26 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~idList = ¶ &amp; TableIDs ( file ) &amp; ¶;
	~value =
		Position ( ~idList ; ¶ &amp; id &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~idList ; ~value ) ; ¶ )
];
	GetValue ( TableNames ( file ) ; ~value )
)</Calculation></CustomFunction><CustomFunction id="32" functionArity="2" visible="True" parameters="name;file" name="ObjectValueListID"><Calculation>/**
 * =====================================
 * ObjectValueListID ( name ; file )
 *
 * RETURNS:
 *		FileMaker's internal ID for a value list.
 *
 * PARAMETERS:
 *		name: The name of the value list
 *		file: The name of the FileMaker file containing the valueList.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		CREATED on 2012-04-13 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~nameList = ¶ &amp; ValueListNames ( file ) &amp; ¶;
	~value =
		Position ( ~nameList ; ¶ &amp; name &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~nameList ; ~value ) ; ¶ );
	~id = GetValue ( ValueListIDs ( file ) ; ~value )
];
	If ( IsEmpty ( ~id ) ; -1 ; /* Else */ ~id )
)</Calculation></CustomFunction><CustomFunction id="33" functionArity="2" visible="True" parameters="id;file" name="ObjectValueListName"><Calculation>/**
 * =====================================
 * ValueListIDName ( id ; file )
 *
 * RETURNS:
 *		The current name of a FileMaker value list, based on its ID.
 *
 * PARAMETERS:
 *		id: FileMaker's internal ID for the value list.
 *		file: The name of the FileMaker file containing the value list.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		CREATED on 2012-04-13 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *		INSPIRED by custom functions by Fabrice Nordman.
 * =====================================
 */

Let ( [
	~idList = ¶ &amp; ValueListIDs ( file ) &amp; ¶;
	~value =
		Position ( ~idList ; ¶ &amp; id &amp; ¶ ; 1 ; 1 );
	~value = PatternCount ( Left ( ~idList ; ~value ) ; ¶ );
	~name = GetValue ( ValueListNames ( file ) ; ~value )
];
	If ( IsEmpty ( ~name ) ; "?" ; /* Else */ ~name )
)</Calculation></CustomFunction><CustomFunction id="34" functionArity="1" visible="True" parameters="veld" name="RepList"><Calculation>RepListLoop ( veld ; FieldReps (veld) ; 1 )</Calculation></CustomFunction><CustomFunction id="35" functionArity="3" visible="True" parameters="veld;repMax;rep" name="RepListLoop"><Calculation>Case 	( rep &gt; repMax 
		; ""
		; Case 	( rep = 1 
			 ; "" 
			 ; ¶ 
			)
			&amp; GetRepetition ( veld ; rep )
			&amp; RepListLoop ( veld ; repMax ; rep+1 )
		)</Calculation></CustomFunction><CustomFunction id="36" functionArity="1" visible="True" parameters="scriptNameToParse" name="ScriptOptionalParameterList"><Calculation>/**
 * =====================================
 * ScriptOptionalParameterList ( scriptNameToParse )
 *
 * RETURNS:
 *		A return-delimited list of optional script parameters according to the
 *		script name and the FileMakerStandards.org convention for listing
 *		parameters in script names.
 *
 * PARAMETERS:
 *		scriptNameToParse: A script name. Defaults to Get ( ScriptName ) when
 *		left empty.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		CREATED on 2012-12-07 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *
 * REFERENCES:
 *		http://filemakerstandards.org/display/cs/Script+naming
 * =====================================
 */

Case (
	/* Step 0, set-up */
	not $~parse.step ;
		Let ( [
			scriptNameToParse =
				If ( IsEmpty ( scriptNameToParse ) ;
					Get ( ScriptName ) ;
					/* Else */ scriptNameToParse
				);
			~length = Length ( scriptNameToParse ) ;
			~start = Position ( scriptNameToParse ; "{" ; ~length ; -1 ) + 1 ;
			~endOptional = Position ( scriptNameToParse ; "}" ; ~start ; 1 ) ;
			~endOptional =
				If ( ~endOptional = 0 ; ~length ; /* Else */ ~endOptional ) ;
			~endRequired = Position ( scriptNameToParse ; ")" ; ~start ; 1 ) ;
			~endRequired =
				If ( ~endRequired = 0 ; ~length ; /* Else */ ~endRequired ) ;
			~end = Min ( ~endOptional ; ~endRequired ) ;
			parameters =
				If ( ~start = 1 ;	// opening "{" not found
					"" ;
				/* Else */
					Middle ( scriptNameToParse ; ~start ; ~end - ~start )
				) ;
			parameters = Substitute ( parameters ; ";" ; ¶ ) ;
			$~parse.parameterCount = ValueCount ( parameters ) ;

			$~parse.step = If ( IsEmpty ( parameters ) ; 2 ; /* Else */ 1 )
		] ;
			ScriptRequiredParameterList ( parameters )
		) ;

	/* Step 1, trim whitespace */
	$~parse.step = 1 ;
		Let ( [
			$~parse.i = $~parse.i + 1 ;
			parameter = Trim ( GetValue ( scriptNameToParse ; $~parse.i ) ) ;
			$~parse.result = List ( $~parse.result ; parameter ) ;
			$~parse.step =
				If ( $~parse.i &lt; $~parse.parameterCount ;
					$~parse.step ;
					/* Else */ $~parse.step + 1
				)
		] ;
			ScriptRequiredParameterList ( scriptNameToParse )
		) ;

	/* Step 2, clean-up and return result */
	$~parse.step = 2 ;
		Let ( [
			~result = $~parse.result ;

			// purge variables
			$~parse.i = "" ;
			$~parse.parameterCount = "" ;
			$~parse.result = "" ;
			$~parse.step = ""
		] ;
			~result
		)
)</Calculation></CustomFunction><CustomFunction id="37" functionArity="1" visible="True" parameters="scriptNameToParse" name="ScriptRequiredParameterList"><Calculation>/**
 * =====================================
 * ScriptRequiredParameterList ( scriptNameToParse )
 *
 * RETURNS:
 *		A return-delimited list of required script parameters according to the
 *		script name and the FileMakerStandards.org convention for listing
 *		parameters in script names.
 *
 * PARAMETERS:
 *		scriptNameToParse: A script name. Defaults to Get ( ScriptName ) when
 *		left empty.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 *		CREATED on 2012-12-07 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 *
 * REFERENCES:
 *		http://filemakerstandards.org/display/cs/Script+naming
 * =====================================
 */

Case (
	/* Step 0, set-up */
	not $~parse.step ;
		Let ( [
			scriptNameToParse =
				If ( IsEmpty ( scriptNameToParse ) ;
					Get ( ScriptName ) ;
					/* Else */ scriptNameToParse
				) ;
			~length = Length ( scriptNameToParse ) ;
			~start = Position ( scriptNameToParse ; "(" ; ~length ; -1 ) + 1 ;
			~endOptional = Position ( scriptNameToParse ; "{" ; ~start ; 1 ) ;
			~endOptional =
				If ( ~endOptional = 0 ; ~length ; /* Else */ ~endOptional ) ;
			~endRequired = Position ( scriptNameToParse ; ")" ; ~start ; 1 ) ;
			~endRequired =
				If ( ~endRequired = 0 ; ~length ; /* Else */ ~endRequired ) ;
			~end = Min ( ~endOptional ; ~endRequired ) ;
			parameters =
				If ( ~start = 1 ;	// opening "(" not found
					"" ;
				/* Else */
					Middle ( scriptNameToParse ; ~start ; ~end - ~start )
				) ;
			parameters = Substitute ( parameters ; ";" ; ¶ ) ;
			$~parse.parameterCount = ValueCount ( parameters ) ;

			$~parse.step = If ( IsEmpty ( parameters ) ; 2 ; /* Else */ 1 )
		];
			ScriptRequiredParameterList ( parameters )
		) ;

	/* Step 1, trim whitespace */
	$~parse.step = 1 ;
		Let ( [
			$~parse.i = $~parse.i + 1 ;
			parameter = Trim ( GetValue ( scriptNameToParse ; $~parse.i ) ) ;
			$~parse.result = List ( $~parse.result ; parameter ) ;
			$~parse.step =
				If ( $~parse.i &lt; $~parse.parameterCount ;
					$~parse.step ;
					/* Else */ $~parse.step + 1
				)
		] ;
			ScriptRequiredParameterList ( scriptNameToParse )
		) ;

	/* Step 2, clean-up and return result */
	$~parse.step = 2 ;
		Let ( [
			~result = $~parse.result ;

			// purge variables
			$~parse.i = "" ;
			$~parse.parameterCount = "" ;
			$~parse.result = "" ;
			$~parse.step = ""
		] ;
			~result
		)
)</Calculation></CustomFunction><CustomFunction id="38" functionArity="5" visible="True" parameters="type;num;dialog;capture;halt" name="SetError"><Calculation>/**
 * =====================================
 * SetError ( type ; num ; dialog ; capture ; halt )
 *
 * PURPOSE:
 *		Explicitly set an error. Useful when setting an application
 *		error or getting a plugin or custom function error
 *		
 * RETURNS:
 *		(array) A $variable array of $error variables
 *		
 * PARAMETERS:
 *		type = (enumeration) fmp, app, plugin, func
 *		num = (number) the numerical value for that error type
 *		dialog = (bool) whether the error should show a dialog
 *		capture = (bool) whether the error should be captured
 *		halt = (bool) whether the error should cause a script halt
 *
 * EXAMPLES:
 *		(see Error function)
 *
 * DEPENDENCIES:
 *		Error(), ErrorData(), ErrorString()
 *
 * NOTES:
 *		See the Error function for information about error overrides
 *
 * HISTORY:
 *		MODIFIED on 2011-03-20 by matt@filemakermagazine.com - reformatted
 *
 * REFERENCES:
 *		none
 * =====================================
 */

Error &amp;
Substitute ( // add semi-colons for proper Let() formatting
	List (
		"$errorState = " &amp; True; // explicitly set the error to true
		"$errorType = " &amp; Quote ( type ); // enumeration app, plugin, func
		"$errorNum = " &amp; num; // error number
		"$errorString = " &amp; Quote ( ErrorString ( type ; num ) ); // override for errorString - put your errors in ErrorString
		"$errorDialog = " &amp; dialog;
		"$errorCapture = " &amp; capture;
		"$errorHalt = " &amp; halt;
	);
	[ ¶ ; ";¶" ]
)</Calculation></CustomFunction><CustomFunction id="39" functionArity="0" visible="True" parameters="" name="Tab"><Calculation>"	"</Calculation></CustomFunction><CustomFunction id="40" functionArity="1" visible="True" parameters="fieldRef" name="TableName"><Calculation>/**
 * =====================================
 * TableName ( fieldRef )
 *
 * PURPOSE:
 *		Convenience function for working with
 *		abstracted table references within code.
 *		
 * RETURNS:
 *		(string) name of just the table portion from a field reference
 *		
 * PARAMETERS:
 *		fieldRef = Absolute field reference
 *
 * EXAMPLES:
 *		TableName ( FunctionalArea » Tablename::fieldName ) = "FunctionalArea » Tablename"
 *
 * DEPENDENCIES:
 *		none
 *
 * NOTES:
 *		This is simply a helper function to avoid having excessive amounts of
 *		similar code wtihin a FileMaker solution.
 *
 * HISTORY:
 *		MODIFIED on 2012-05-11 by matt@filemakermagazine.com - added
 *
 * REFERENCES:
 *		(see FieldName custom function)
 * =====================================
 */

GetValue ( Substitute ( GetFieldName ( fieldRef ) ; "::" ; ¶ ) ; 1 )</Calculation></CustomFunction><CustomFunction id="41" functionArity="1" visible="True" parameters="extendedPrivilegeNaam" name="securityToegang"><Calculation>PatternCount 
	( 
		"¶" &amp; Get ( AccountExtendedPrivileges ) &amp; "¶"  
	; 
		"¶" &amp; extendedPrivilegeNaam &amp; "¶" 
	)</Calculation></CustomFunction><CustomFunction id="42" functionArity="0" visible="True" parameters="" name="TriggersAreActive"><Calculation>/**
 * =====================================
 * TriggersAreActive
 *
 * PURPOSE:
 * TriggersAreActive checks a global variable to identify whether or not script
 * triggers should be allowed to run. This function is best used in concert with
 * the TriggersDisable, TriggersEnable, and TriggersReset
 * functions.
 *
 * RETURNS:
 * False (0) if triggers should be suppressed; True (1) otherwise.
 *
 * PARAMETERS: none
 *
 * REFERENCED VARIABLES:
 * $$~DISABLETRIGGERS
 *
 * DEPENDENCIES: none
 *
 * EXAMPLE (triggered script):
 * If [ TriggersAreActive ]
 *        # Do something
 * End If
 *
 * HISTORY:
 * MODIFIED on 2010-12-13 by jbante@supportgroup.com to use names suggested at
 * filemakerstandards.org.
 * CREATED on 2010-12-12 by Jeremy Bante of The Support Group (jbante@supportgroup.com).
 *
 * REFERENCES:
 * Supressible Triggered Scripts Best Practice: http://filemakerstandards.org/display/bp/Suppressible+Triggered+Scripts
 * =====================================
 */
not $$~DISABLETRIGGERS</Calculation></CustomFunction><CustomFunction id="43" functionArity="0" visible="True" parameters="" name="TriggersDisable"><Calculation>/**
 * =====================================
 * TriggersDisable
 *
 * PURPOSE:
 * TriggersDisable sets global variables to indicate that the current script is
 * suppressing triggers. This script must be called from the context of a
 * script; otherwise, it will not suppress triggers, and it will return False.
 * In order to be suppressed, a script called via trigger should use the
 * TriggersAreActive function to decide whether or not to run.
 *
 * RETURNS:
 * True (1) if called from the context of a script, and therefore triggers have
 * been suppressed; False (0) otherwise.
 *
 * PARAMETERS: none
 *
 * REFERENCED VARIABLES:
 * $$~DISABLETRIGGERS
 * $$~DISABLETRIGGERS.SCRIPTS
 *
 * DEPENDENCIES: none
 *
 * EXAMPLE (script):
 * Set Variable [ $ignoreMe ; TriggersDisable ]
 *        # Do something
 * Set Variable [ $ignoreMe ; TriggersEnable ]
 *
 * NOTES:
 * This function should *always* be used in pairs with the TriggersEnable
 * function.
 *
 * HISTORY:
 * MODIFIED on 2010-12-13 by jbante@supportgroup.com to use names suggested at
 * filemakerstandards.org.
 * CREATED on 2010-12-12 by Jeremy Bante of The Support Group (jbante@supportgroup.com).
 *
 * REFERENCES:
 * Supressible Triggered Scripts Best Practice: http://filemakerstandards.org/display/bp/Suppressible+Triggered+Scripts
 * =====================================
 */

Let ( [
        ~scriptName = Get ( ScriptName );
        ~scriptIsRunning = not IsEmpty ( ~scriptName );
        $$~DISABLETRIGGERS.SCRIPTS =
                If ( ~scriptIsRunning;
                        ~scriptName &amp; "¶" &amp; $$~DISABLETRIGGERS.SCRIPTS;
                        /*else*/ $$~DISABLETRIGGERS.SCRIPTS
                );
        $$~DISABLETRIGGERS =
                If ( ~scriptIsRunning;
                        True;
                        /*else*/ $$~DISABLETRIGGERS
                )
];
        ~scriptIsRunning
)</Calculation></CustomFunction><CustomFunction id="44" functionArity="0" visible="True" parameters="" name="TriggersEnable"><Calculation>/**
 * =====================================
 * TriggersEnable
 *
 * PURPOSE:
 * TriggersEnable sets global variables to indicate that the current script is
 * no longer suppressing triggers. This function will also turn off trigger
 * suppression altogether if there are no other scripts suppressing triggers. In
 * order to be suppressed, a script called via trigger should use the
 * TriggersAreActive function to decide whether or not to run.
 *
 * RETURNS:
 * True (1) if TriggersEnable successfully removed the current script from
 * the list of scripts suppressing triggers; False (0) otherwise.
 *
 * PARAMETERS: none
 *
 * REFERENCED VARIABLES:
 * $$~DISABLETRIGGERS
 * $$~DISABLETRIGGERS.SCRIPTS
 *
 * DEPENDENCIES: none
 *
 * EXAMPLE (script):
 * Set Variable [ $ignoreMe ; TriggersDisable ]
 *        # Do something
 * Set Variable [ $ignoreMe ; TriggersEnable ]
 *
 * NOTES:
 * This function should *always* be used in pairs with the TriggersDisable
 * function.
 *
 * HISTORY:
 * MODIFIED on 2010-12-13 by jbante@supportgroup.com to use names suggested at
 * filemakerstandards.org.
 * CREATED on 2010-12-12 by Jeremy Bante of The Support Group (jbante@supportgroup.com).
 *
 * REFERENCES:
 * Supressible Triggered Scripts Best Practice: http://filemakerstandards.org/display/bp/Suppressible+Triggered+Scripts
 * =====================================
 */

Let ( [
        ~lastScript = GetValue ( $$~DISABLETRIGGERS.SCRIPTS ; 1 );
        ~enableTriggers = Get ( ScriptName ) = ~lastScript; //boolean indicating script name match
        $$~DISABLETRIGGERS.SCRIPTS =
                If ( ~enableTriggers;
                        RightValues (
                        	$$~DISABLETRIGGERS.SCRIPTS;
                        	ValueCount ( $$~DISABLETRIGGERS.SCRIPTS ) - 1
                        );
                        /*else*/ $$~DISABLETRIGGERS.SCRIPTS
                );
        ~scriptCount = ValueCount ( $$~DISABLETRIGGERS.SCRIPTS );
        $$~DISABLETRIGGERS = If ( ~scriptCount ; True ; /*else*/ "" )
];
        ~enableTriggers or not ~scriptCount //ScriptName was found and removed, or there are no suppressing scripts
)</Calculation></CustomFunction><CustomFunction id="45" functionArity="0" visible="True" parameters="" name="TriggersReset"><Calculation>/**
 * =====================================
 * TriggersReset
 *
 * PURPOSE:
 * TriggersReset sets global variables to indicate that script triggers should
 * be allowed to run, regardless of any persisting instructions to the contrary
 * from any script. This may be useful to recover from a situation where a
 * script forgot to call TriggersEnable at the end of operation. In order to be
 * suppressed, a script called via trigger should use the TriggersAreActive
 * function to decide whether or not to run.
 *
 * RETURNS: "" (null)
 *
 * PARAMETERS: none
 *
 * REFERENCED VARIABLES:
 * $$~DISABLETRIGGERS
 * $$~DISABLETRIGGERS.SCRIPTS
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 * MODIFIED on 2010-12-13 by jbante@supportgroup.com to use names suggested at
 * filemakerstandards.org.
 * CREATED on 2010-12-12 by Jeremy Bante of The Support Group (jbante@supportgroup.com).
 *
 * REFERENCES:
 * Supressible Triggered Scripts Best Practice: http://filemakerstandards.org/display/bp/Suppressible+Triggered+Scripts
 * =====================================
 */

Let ( [
        $$~DISABLETRIGGERS.SCRIPTS = "";
        $$~DISABLETRIGGERS = ""
];
        ""
)</Calculation></CustomFunction><CustomFunction id="5" functionArity="0" visible="True" parameters="" name="UniqueID"><Calculation>get ( LayoutTableName ) &amp; " " &amp; Get ( UUID )</Calculation></CustomFunction><CustomFunction id="47" functionArity="3" visible="True" parameters="keys;values;scope" name="VariableList"><Calculation>/*
 * =====================================================
 * VariableList ( keys; values; scope )
 * 
 * RETURNS:
 *		(string) key/value pairs as $key = value in
 *		positional order
 *
 * PARAMETERS:
 *		@keys = List() of key names
 *		@values = List() of values
 *		@scope = (enum) global, local
 *
 * DEPENDENCIES:
 *		none
 *
 * PURPOSE:
 *		Takes two compliment set of lists
 *		and turns them into FMP defined variables
 *
 * NOTES:
 *		none
 * =====================================================
 *
 */
 
Let ( [
	~singleValue = ValueCount ( keys ) = 1 and ValueCount ( values ) = 1; // only one key/value pair
	~isValid  = ValueCount ( keys ) = ValueCount ( values ); // both lists have the same number of values
	~notEmpty = not IsEmpty( keys ) and not IsEmpty ( values ); // lists aren't empty
	~value = GetValue ( values ; 1 );
	~valueIsNumber  = Length ( GetAsNumber ( Filter ( ~value; "0123456789.-" ) ) ) = Length ( ~value );
	~value = Case (
		~valueIsNumber;
			~value;

		Quote ( ~value ) // default for all strings
	);
	~string = If ( scope = "global" ; "$$" ; "$" ) &amp; GetValue ( keys ; 1 )  &amp; " = " &amp; ~value &amp; If ( ValueCount( keys ) = 1; "" ; ";¶" )
];
	Case (
		~singleValue;
			~string;
			
		~isValid and ~notEmpty;
			~string &amp;
			VariableList ( MiddleValues ( keys ; 2 ; 1000000 ) ; MiddleValues ( values ; 2 ; 1000000 ) ; scope );
		
		// default
		"ERROR » Lists don't match in length"
	)
)

/*
// Testing code
~list (
  List(
    "foo";
    "bar"
  )
;
  List(
    "single value";
    "multiple¶values"
  )
; "local" )
*/</Calculation></CustomFunction><CustomFunction id="48" functionArity="1" visible="True" parameters="nameList" name="VerifyVariablesNotEmpty"><Calculation>/**
 * =====================================
 * VerifyVariablesNotEmpty ( nameList )
 *
 * RETURNS:
 *		True (1) if a locally scoped $variable matching each value in nameList
 *		is not empty; False (0) otherwise.
 *
 * PARAMETERS:
 *		nameList: A return-limited list of names to check. Names do not need to
 *		include $ prefixes.
 *
 * DEPENDENCIES: none
 *
 * NOTES:
 *		Names containing "$" or "$$" prefixes will be treated as identical to
 *		names not beginning with those prefixes — this function only checks for
 *		local $variables.
 *
 * HISTORY:
 *		CREATED on 2012-12-07 by Jeremy Bante &lt;http://scr.im/jbante&gt;.
 * =====================================
 */

If ( IsEmpty ( nameList );
	True;
/* Else */
	Let ( [
		nameList =	// normalize nameList so all values begin with "$"
			Substitute (
				"/*start*/¶" &amp; nameList &amp; "/*end*/";
				[ "¶$$" ; "¶" ];
				[ "¶$" ; "¶" ];
				[ "¶" ; "¶$" ];
				[ "/*start*/¶" ; "" ];
				[ "/*start*/" ; "" ]
			);
		~testExpression =
			"not IsEmpty ( "
			&amp; Substitute ( nameList ; ¶ ; " )¶and not IsEmpty ( " )
			&amp; " ) "
	];
		If ( IsValidExpression ( ~testExpression );
			Evaluate ( ~testExpression );
			/* Else */ False
		)
	)
)</Calculation></CustomFunction><CustomFunction id="49" functionArity="1" visible="True" parameters="dimension" name="WindowCenter"><Calculation>/**
 * =====================================================
 * WindowCenter ( dimension )
 * 
 * PARAMETERS:
 *		@dimension (enumeration) Vertical, Horizontal
 *
 * RETURNS:
 *		(int) Screen position value based on dimension
 *		supplied

 * DEPENDENCIES:
 *		none

 * NOTES:
 *		Using a locally scoped variable within your
 *		script will alter what this function returns
 *		$parentWindowHeight for window height of parent
 *		$parentWindowWidth for window width of parent
 *		$parentWindowTop for window top of parent
 *		$parentWindowLeft for window left of parent
 * =====================================================
 * 
 */

Let ( [
	~vertical = PatternCount ( dimension ; "vert" ) or dimension = "y";
	~horizontal = PatternCount ( dimension ; "horiz" ) or dimension = "x";
	~parentIsSet = not IsEmpty ( $parentWindowTop )
					and not IsEmpty ( $parentWindowLeft )
					and not IsEmpty ( $parentWindowWidth )
					and not IsEmpty ( $parentWindowHeight );
	~parentOnScreen = ~parentIsSet
					and ( $parentWindowTop + $parentWindowHeight ≤ Get ( WindowDesktopHeight )
					and $parentWindowLeft + $parentWindowWidth ≤ Get ( WindowDesktopWidth ) );
	~parentHeight = If ( not ~parentIsSet or not ~parentOnScreen;
			Get ( WindowDesktopHeight );
		/*else*/
			$parentWindowHeight
		);
	~parentWidth = If ( not ~parentIsSet or not ~parentOnScreen;
			Get ( WindowDesktopWidth );
		/*else*/
			$parentWindowWidth
		);
	~childHeight = If ( IsEmpty ( $childWindowHeight );
			Get ( WindowHeight );
		/*else*/
			$childWindowHeight
		);
	~childWidth = If ( IsEmpty ( $childWindowWidth );
			Get ( WindowWidth );
		/*else*/
			$childWindowWidth
		)
];
	Case (
		~vertical;
			( ~parentHeight / 2) - ( ~childHeight / 2 )
			+ If ( ~parentOnScreen ; $parentWindowTop );
		~horizontal;
			( ~parentWidth / 2) - ( ~childWidth / 2 )
			+ If ( ~parentOnScreen ; $parentWindowLeft )
	)
)</Calculation></CustomFunction><CustomFunction id="50" functionArity="0" visible="True" parameters="" name="WindowProperties"><Calculation>/*
 * =====================================================
 * WindowProperties ( )
 * 
 * RETURNS:
 * 		Let () formatted list of global variables with prefix of 'window'
 *
 * PARAMETERS:
 *		none
 *
 * EXAMPLES:
 * 		Substitute ( WindowProperties ; "$$" ; "$" ) //= locally scoped $window[Value] variables
 * 		Substitute ( WindowProperties ; "$$" ; "$parent" ) //= locally scoped $parentwindow[Value] variables
 *
 * RETURNS:
 *		formatted global let variables
 *
 * DEPENDENCIES:
 *		none
 *
 * NOTES:
 *		See WindowCenter companion function. It will center a window within a parent
 *		window when $parentWindow[Value] variables are set.
 * =====================================================
 * 
 */

Substitute (
	List (
		"$$windowName = " &amp; Quote ( Get ( WindowName ) );
		"$$windowLayout = " &amp; Quote ( Get ( LayoutName ) );
		"$$windowLayoutID = " &amp; GetValue ( LayoutIDs ( Get ( FileName ) ) ; Get ( LayoutNumber ) );
		"$$windowTop = " &amp; Get ( WindowTop );
		"$$windowLeft = " &amp; Get ( WindowLeft );
		"$$windowWidth = " &amp; Get ( WindowWidth );
		"$$windowHeight = " &amp; Get ( WindowHeight );
		"$$windowViewAs = " &amp; Get ( LayoutViewState );
		"$$windowMode = " &amp; Get ( WindowMode );
		"$$windowStatusArea = " &amp; Get ( StatusAreaState );
		"$$windowZoomLevel = " &amp; Get ( WindowZoomLevel );
		"$$windowTextRuler = " &amp; Get ( TextRulerVisible );
	);
	[ ¶ ; ";¶" ] // adding semi colons to each line
)</Calculation></CustomFunction></fmxmlsnippet></Clipboard><Picture></Picture></FMClipboard>